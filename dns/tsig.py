"""DNS TSIG support."""
import base64
import hashlib
import hmac
import struct
import dns.exception
import dns.name
import dns.rcode
import dns.rdataclass


class BadTime(dns.exception.DNSException):
    """The current time is not within the TSIG's validity time."""


class BadSignature(dns.exception.DNSException):
    """The TSIG signature fails to verify."""


class BadKey(dns.exception.DNSException):
    """The TSIG record owner name does not match the key."""


class BadAlgorithm(dns.exception.DNSException):
    """The TSIG algorithm does not match the key."""


class PeerError(dns.exception.DNSException):
    """Base class for all TSIG errors generated by the remote peer"""


class PeerBadKey(PeerError):
    """The peer didn't know the key we used"""


class PeerBadSignature(PeerError):
    """The peer didn't like the signature we sent"""


class PeerBadTime(PeerError):
    """The peer didn't like the time we sent"""


class PeerBadTruncation(PeerError):
    """The peer didn't like amount of truncation in the TSIG we sent"""


HMAC_MD5 = dns.name.from_text('HMAC-MD5.SIG-ALG.REG.INT')
HMAC_SHA1 = dns.name.from_text('hmac-sha1')
HMAC_SHA224 = dns.name.from_text('hmac-sha224')
HMAC_SHA256 = dns.name.from_text('hmac-sha256')
HMAC_SHA256_128 = dns.name.from_text('hmac-sha256-128')
HMAC_SHA384 = dns.name.from_text('hmac-sha384')
HMAC_SHA384_192 = dns.name.from_text('hmac-sha384-192')
HMAC_SHA512 = dns.name.from_text('hmac-sha512')
HMAC_SHA512_256 = dns.name.from_text('hmac-sha512-256')
GSS_TSIG = dns.name.from_text('gss-tsig')
default_algorithm = HMAC_SHA256
mac_sizes = {HMAC_SHA1: 20, HMAC_SHA224: 28, HMAC_SHA256: 32,
    HMAC_SHA256_128: 16, HMAC_SHA384: 48, HMAC_SHA384_192: 24, HMAC_SHA512:
    64, HMAC_SHA512_256: 32, HMAC_MD5: 16, GSS_TSIG: 128}


class GSSTSig:
    """
    GSS-TSIG TSIG implementation.  This uses the GSS-API context established
    in the TKEY message handshake to sign messages using GSS-API message
    integrity codes, per the RFC.

    In order to avoid a direct GSSAPI dependency, the keyring holds a ref
    to the GSSAPI object required, rather than the key itself.
    """

    def __init__(self, gssapi_context):
        self.gssapi_context = gssapi_context
        self.data = b''
        self.name = 'gss-tsig'


class GSSTSigAdapter:

    def __init__(self, keyring):
        self.keyring = keyring

    def __call__(self, message, keyname):
        if keyname in self.keyring:
            key = self.keyring[keyname]
            if isinstance(key, Key) and key.algorithm == GSS_TSIG:
                if message:
                    GSSTSigAdapter.parse_tkey_and_step(key, message, keyname)
            return key
        else:
            return None


class HMACTSig:
    """
    HMAC TSIG implementation.  This uses the HMAC python module to handle the
    sign/verify operations.
    """
    _hashes = {HMAC_SHA1: hashlib.sha1, HMAC_SHA224: hashlib.sha224,
        HMAC_SHA256: hashlib.sha256, HMAC_SHA256_128: (hashlib.sha256, 128),
        HMAC_SHA384: hashlib.sha384, HMAC_SHA384_192: (hashlib.sha384, 192),
        HMAC_SHA512: hashlib.sha512, HMAC_SHA512_256: (hashlib.sha512, 256),
        HMAC_MD5: hashlib.md5}

    def __init__(self, key, algorithm):
        try:
            hashinfo = self._hashes[algorithm]
        except KeyError:
            raise NotImplementedError(
                f'TSIG algorithm {algorithm} is not supported')
        if isinstance(hashinfo, tuple):
            self.hmac_context = hmac.new(key, digestmod=hashinfo[0])
            self.size = hashinfo[1]
        else:
            self.hmac_context = hmac.new(key, digestmod=hashinfo)
            self.size = None
        self.name = self.hmac_context.name
        if self.size:
            self.name += f'-{self.size}'


def _digest(wire, key, rdata, time=None, request_mac=None, ctx=None, multi=None
    ):
    """Return a context containing the TSIG rdata for the input parameters
    @rtype: dns.tsig.HMACTSig or dns.tsig.GSSTSig object
    @raises ValueError: I{other_data} is too long
    @raises NotImplementedError: I{algorithm} is not supported
    """
    pass


def _maybe_start_digest(key, mac, multi):
    """If this is the first message in a multi-message sequence,
    start a new context.
    @rtype: dns.tsig.HMACTSig or dns.tsig.GSSTSig object
    """
    pass


def sign(wire, key, rdata, time=None, request_mac=None, ctx=None, multi=False):
    """Return a (tsig_rdata, mac, ctx) tuple containing the HMAC TSIG rdata
    for the input parameters, the HMAC MAC calculated by applying the
    TSIG signature algorithm, and the TSIG digest context.
    @rtype: (string, dns.tsig.HMACTSig or dns.tsig.GSSTSig object)
    @raises ValueError: I{other_data} is too long
    @raises NotImplementedError: I{algorithm} is not supported
    """
    pass


def validate(wire, key, owner, rdata, now, request_mac, tsig_start, ctx=
    None, multi=False):
    """Validate the specified TSIG rdata against the other input parameters.

    @raises FormError: The TSIG is badly formed.
    @raises BadTime: There is too much time skew between the client and the
    server.
    @raises BadSignature: The TSIG signature did not validate
    @rtype: dns.tsig.HMACTSig or dns.tsig.GSSTSig object"""
    pass


def get_context(key):
    """Returns an HMAC context for the specified key.

    @rtype: HMAC context
    @raises NotImplementedError: I{algorithm} is not supported
    """
    pass


class Key:

    def __init__(self, name, secret, algorithm=default_algorithm):
        if isinstance(name, str):
            name = dns.name.from_text(name)
        self.name = name
        if isinstance(secret, str):
            secret = base64.decodebytes(secret.encode())
        self.secret = secret
        if isinstance(algorithm, str):
            algorithm = dns.name.from_text(algorithm)
        self.algorithm = algorithm

    def __eq__(self, other):
        return (isinstance(other, Key) and self.name == other.name and self
            .secret == other.secret and self.algorithm == other.algorithm)

    def __repr__(self):
        r = f"<DNS key name='{self.name}', " + f"algorithm='{self.algorithm}'"
        if self.algorithm != GSS_TSIG:
            r += f", secret='{base64.b64encode(self.secret).decode()}'"
        r += '>'
        return r
